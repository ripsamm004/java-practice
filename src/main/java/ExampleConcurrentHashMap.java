import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by shiful on 22/04/2018.
 *
 * Differences between ConcurrentHashMap and HashMap, Hashtable and synchronizedMap
 HashMap is a non-threadsafe Map which should not be used by multiple threads.
 Hashtable is a thread-safe Map that allows only one thread to execute a read/update operation at a time.
 synchronizedMap is a thread-safe wrapper on a Map implementation. It is generated by the Collections.synchronizedMap(Map)  factory method.
 A synchronizedMap also allows only a single thread to work on the map at a time.
 And ConcurrentHashMap is a thread-safe Map with greater flexibility and higher scalability as it uses a special locking mechanism
 that enables multiple threads to read/update the map concurrently.
 Therefore, you can use ConcurrentHashMap to replace HashMap/Hastable/synchronizedMap for concurrency needs without locking the whole map.
 I hope with this understanding, you will be able to decide when, where and how to use ConcurrentHashMap in your Java programs.

 ConcurrentHashMap is an implementation of ConcurrentMap which is a subtype of the Map interface. A ConcurrentMap defines the following atomic operations:
 putIfAbsent(K key, V value): associates the specified key to the specified value if the key is not already associated with a value.
 This method is performed atomically, meaning that no other threads can intervene in the middle of checking absence and association.
 remove(Object key, Object value): removes the entry for a key only if currently mapped to some value. This method is performed atomically.
 replace(K key, V value): replaces the entry for a key only if currently mapped to some value. This method is performed atomically.
 replace(K key, V oldValue, V newValue): replaces the entry for a key only if currently mapped to a given value. This method is performed atomically.
 Also note that the methods size() and isEmpty() may return an approximation instead of an exact count due to the concurrent nature of the map.
 ConcurrentHashMap does not allow null key and null value.
 ConcurrentHashMap has such advanced concurrent capabilities because it uses a finer-grained locking mechanism. We donâ€™t
 delve in to the details of the locking algorithm, but understand that the ConcurrentHashMap uses different locks to lock
 different parts of the map, which enables concurrent reads and updates.


 http://www.codejava.net/java-core/concurrency/java-concurrent-collection-concurrenthashmap-examples

 */
public class ExampleConcurrentHashMap {

    public void testConcurrectHashMap() {
        //ConcurrentHashMap
        Map<String, String> myMap = new ConcurrentHashMap<String, String>();
        myMap.put("1", "1");
        myMap.put("2", "1");
        myMap.put("3", "1");
        myMap.put("4", "1");
        myMap.put("5", "1");
        myMap.put("6", "1");
        // myMap.put(null, "1");  // java.lang.NullPointerException
        System.out.println("ConcurrentHashMap before iterator: " + myMap);
        Iterator<String> it = myMap.keySet().iterator();

        while (it.hasNext()) {
            String key = it.next();
            if (key.equals("3")) myMap.put(key + "new", "new3");
        }

        System.out.println("ConcurrentHashMap after iterator: " + myMap);
    }


}
